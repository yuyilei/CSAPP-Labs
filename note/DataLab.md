字长：指明指针数据的大小
字长决定虚拟地址空间的大小

大端法：高有效位到低有效位顺序
小端法：与大端法相反，大多数intel兼容机

逻辑右移，算数右移
有符号数：一般算数右移
无符号数：必须逻辑右移

无符号数编码具有唯一性
补码编码具有唯一性

头文件：< limit.h >  INT_MAX, INT_MIN

强制转化类型保持位值结果不变，只改变了解释位值的方式。

C语言标准没有规定哪种形式表示有符号数，但是大多数用补码。

有符号数+无符号数 —> 将有符号数转化为无符号数。
同 ==， <, > 等

扩展一个数的位：
1. 无符号数的零扩展
2. 补码数的符号扩展 （补码数的符号扩展保持数值不变）

隐式的强制转化类型会造成问题。
如：return strlen(a) - strlen(b) > 0 
其中 strlen 是 unsigned  
当  a的长度小于 b时，为负数，但是变成了一个很大的正数。

检测无符号数加法中的溢出。
S = x + y,  当 　S  < x 是时溢出。

补码加法溢出：
S = x + y 
 当 x>0, y>0 时， S<0;
 当 x<0, y<0 时， S>0;

 补码加法会形成阿贝尔群，x+y-y无论是否溢出，总会得到x，不能用于检查是否溢出

无符号和补码相乘的位级等价性：
无符号和补码形式的乘法的全部位级可能不同，但是截断后的位级相同。


思考：检查乘法的溢出？

思考：
int x, y 
Unsigned  ux = x , uy = y ; 
( x > 0 ) || ( (x - 1 ) < 0 ) 错 x = Tmin32时，x = Tmax32
x < 0 || -x >= 0   对
x > 0 || -x >= 0  错，x = Tmin32
x + y = ux + uy 对

浮点数：CSAPP 第78到82讲的非常清楚，不再赘述



