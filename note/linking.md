# 链接 （Linking）

链接是将各种代码和数据片段收集并组合成为一个可执行文件的过程，可以发生在 **编译**、**加载**、**运行**时，由 **链接器** 完成。

下图是一个生成可执行文件的过程:

![](https://github.com/yuyilei/CSAPP-Labs/blob/master/picture/compiler.png?raw=true)

生成可执行文件之后，运行可执行文件：

大致经历了以下步骤

1. 用户请求运行程序时，操作系统会读取存储在磁盘上的可执行文件，在linux系统上可执行文件就ELF格式文件，为用户分配4G的虚拟内存空间，

2. 根据文件的指示，把不同的文件内容放到虚拟内存空间。

3. 根据文件的指示，系统设置代码段和数据段寄存器。

4. 根据文件的指示, 跳转到用户的代码的入口地址（一般就是main函数)。

5. 从main开始，执行指令，处理数据，直到程序结束。虽然在这个过程中，系统会多次切换到其他进程，但对用户程序来说没有影响，可以认为计算机只为我们服务。


## 目标文件

目标文件有三种：

1. **可重定向目标文件(relocatable)** ：包含二进制代码和数据，在编译时与其他可重定向目标文件合并，创建一个可执行文件。
2. **可执行文件(executable)** ：包含二进制代码和数据，可以直接运行。
3. **共享目标文件(shared object)** ：特殊的可重定向目标文件，在加载或运行时被动态加载入内存并链接。 

目标文件都是 **字节序列**。

目标文件的文件格式是：ELF(Executable and Linkable Forma) 

ELF文件格式这篇文件讲的比较清楚 --> [ELF文件](https://blog.csdn.net/feglass/article/details/51469511)

## 静态链接与动态链接

在 **链接**阶段，有两种链接方式，静态链接和动态链接，对应的库分别是静态链接库和动态链接库（共享库）。

gcc 的参数 -l：指定链接时需要的库。编译器查找链接库时有隐含的命名规则，即在给出的名字前面加上lib，后面加上`.a`或`.so`来确定库的名称。

### 静态链接 

静态链接：以一组可重定位的目标文件作为输入，生成一个完全连接的可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的代码和数据节（section）组成。静态链接中，编译链接可执行文件时，链接器从库中 **复制**这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。

静态链接的优点是：方便程序移植，因为可执行程序与库函数再无关系，放在如何环境当中都可以执行。

静态链接的缺点是：文件太大，往往实现很小的一个功能就需要占用很大的空间（因为是复制的方式）；而且每次库文件升级的话，都要重新编译源文件；并且 不同的源程序中调用了相同的函数，这些函数不能复用，会有多个拷贝，造成内存空间的浪费。

将相关的函数编译为独立的目标模块，然后封装成一个独立的 **静态链接库**，在Linux系统中，静态链接库以存档文件的形式，保存在磁盘上，存档文件是一组连接起来的可重定向目标文件的集合，其头部描述成员目标文件的大小和位置。

一般，Windows下，静态链接库通常后缀为`.lib`，Linux下，静态库通常后缀为`.a`。 

Linux下静态链接：

```
gcc -c sum.c                               --> 生成sum.o
ar rcs libsum.a sum.o                      --> 生成静态链接库 libsum.a 
gcc -c main.o                              --> 生成main.o
gcc -static -o proc main.o ./libsum.a      --> 静态链接生成完全链接的可执行文件
```

### 动态链接

动态链接：动态链接发生在 **运行**时，程序并不在一开始就完成动态链接，到真正调用动态库代码时，载入程序才计算(被调用的那部分)动态代码的逻辑地址，然后等到某个时候，程序又需要调用另外某块动态代码时，载入程序又去计算这部分代码的逻辑地址，所以，这种方式使程序初始化时间较短，但运行期间的性能比不上静态链接的程序。

动态链接的优点：生成的可执行文件较小；多个程序共用一个动态链接库，动态链接库在内存中只有一份拷贝，供所有程序使用，避免的内存空间的浪费；

动态链接的缺点：可移植性不好，如果两台电脑运行环境不同，动态库存放的位置不一样，很可能导致程序运行失败；使用动态链接库的应用程序不是自完备的，运行时需动态链接库。

一般，Windows下，动态链接库通常后缀为`.dll`，Linux下，动态链接库通常后缀为`.so`。  

Linux系统为动态链接器提供了接口，允许应用程序在运行时加载和运行动态链接库,`dlopen`，`dlsym`等。

动态链接：

```
g++ -fPIC -shared -o libsum.so sum.c                 --> 生成libsum.so的共享库      
g++ -o main main.cpp -L./libsum -lsum                --> 生成可执行文件。
```

其中，-fPIC ：表示编译为位置独立的代码，用于编译共享库。

位置无关代码： 为了使多个正在运行的程序共享内存中的 共享库，要求高共享库无需在在内存中的何处，都不需要链接器修改。 所以，可以加载而无需重定向的代码称为 **位置无关代码**，共享库必须时位置无关代码。

#### 库打桩

库打桩（interposition）是Linux链接器所提供的技术，允许用户截获对共享库函数的调用，并执行自己的代码（当然是在普通权限下，管理员权限通常是禁止使用该技术的）。

打桩机制的基本实现原理：给定需要打桩的目标函数，常见一个wrapper函数，其原型和目标函数一致。利用特殊的打桩机制，可以实现让系统调用你的wrapper函数而不是目标函数，打桩可以发生在 编译，链接或运行时。 

其中，链接时打桩，Linux静态链接器支持用--wrap f标志进行链接时打桩。（这个标志告诉链接器，把对符号f的引用解析成__wrap_f（前缀是两个下划线），还要对符号__real_f的引用解析成f） 